<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>輸出 - Rust 中的命令列應用程式</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../src/special-content.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">開始</a></li><li class="chapter-item expanded "><a href="../tutorial/index.html"><strong aria-hidden="true">1.</strong> 在15分鐘內建立一個命令列應用程式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorial/setup.html"><strong aria-hidden="true">1.1.</strong> 專案初始化設置</a></li><li class="chapter-item expanded "><a href="../tutorial/cli-args.html"><strong aria-hidden="true">1.2.</strong> 解析命令列參數</a></li><li class="chapter-item expanded "><a href="../tutorial/impl-draft.html"><strong aria-hidden="true">1.3.</strong> 首次運行</a></li><li class="chapter-item expanded "><a href="../tutorial/errors.html"><strong aria-hidden="true">1.4.</strong> 合適的回饋錯誤</a></li><li class="chapter-item expanded "><a href="../tutorial/output.html" class="active"><strong aria-hidden="true">1.5.</strong> 輸出</a></li><li class="chapter-item expanded "><a href="../tutorial/testing.html"><strong aria-hidden="true">1.6.</strong> 測試</a></li><li class="chapter-item expanded "><a href="../tutorial/packaging.html"><strong aria-hidden="true">1.7.</strong> 打包且發布一個Rust工具</a></li></ol></li><li class="chapter-item expanded "><a href="../in-depth/index.html"><strong aria-hidden="true">2.</strong> 深入探究主題</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../in-depth/signals.html"><strong aria-hidden="true">2.1.</strong> 訊號處理</a></li><li class="chapter-item expanded "><a href="../in-depth/config-files.html"><strong aria-hidden="true">2.2.</strong> 使用配置檔</a></li><li class="chapter-item expanded "><a href="../in-depth/exit-code.html"><strong aria-hidden="true">2.3.</strong> 退出狀態碼</a></li><li class="chapter-item expanded "><a href="../in-depth/human-communication.html"><strong aria-hidden="true">2.4.</strong> 和人互動</a></li><li class="chapter-item expanded "><a href="../in-depth/machine-communication.html"><strong aria-hidden="true">2.5.</strong> 和機器互動</a></li><li class="chapter-item expanded "><a href="../in-depth/docs.html"><strong aria-hidden="true">2.6.</strong> 為你的 CLI 程式產生文件 </a></li></ol></li><li class="chapter-item expanded "><a href="../resources/index.html"><strong aria-hidden="true">3.</strong> 相關資源</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust 中的命令列應用程式</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-cli/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="輸出"><a class="header" href="#輸出">輸出</a></h1>
<h2 id="在終端機下輸出-hello-world"><a class="header" href="#在終端機下輸出-hello-world">在終端機下輸出 “Hello World”</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Hello World");
<span class="boring">}</span></code></pre></pre>
<p>嗯，這很容易。</p>
<p>太好了，進入下一個主題。</p>
<h2 id="使用-println"><a class="header" href="#使用-println">使用 <code>println!</code></a></h2>
<p>您幾乎可以在終端機下使用 <code>println!</code> 巨集輸出所有您想輸出的東西。</p>
<p>這個巨集有一些非常驚人的功能，而且還有特殊的語法。
它希望您編寫一個字串文字作為第一個參數，包含將要填入的佔位符號
再透過後面作為進一步參數的參數值。</p>
<p>範例:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 42;
println!("My lucky number is {}.", x);
<span class="boring">}</span></code></pre></pre>
<p>將會輸出</p>
<pre><code class="language-console">My lucky number is 42.
</code></pre>
<p>上面字串中的大括弧（ <code>{}</code> ）就是佔位符號中的一種。
這是預設的佔位符號型別， 它嘗試以人類可讀的方式來輸出給定的參數的值。
對於數值和字串，這會很好用，
但並不是所有的型別都可以。
這就是為什麼還有一個 “除錯表示(debug representation)”，
你可以使用這個佔位符號來呼叫它 <code>{:?}</code>。</p>
<p>範例</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let xs = vec![1, 2, 3];
println!("The list is: {:?}", xs);
<span class="boring">}</span></code></pre></pre>
<p>將會輸出</p>
<pre><code class="language-console">The list is: [1, 2, 3]
</code></pre>
<p>如果你想在偵錯和記錄 中輸出自己建置的型別，
大部分情況下你可以在型別定義上新增 <code>#[derive(Debug)]</code> 屬性。</p>
<aside>
<p><strong>說明:</strong></p>
<p>“使用者友善(User-friendly)” 的輸出是使用 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html"><code>Display</code></a> 特性完成的，
除錯輸出（適用於開發者）使用 <a href="https://doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html"><code>Debug</code></a> 特徵。
您可以在 <code>println!</code> 中找到更多關於可以使用的語法的相關資訊。
在<a href="https://doc.rust-lang.org/1.39.0/std/fmt/index.html"><code>std::fmt</code>模組的文件</a>中。</p>
</aside>
<h2 id="輸出錯誤"><a class="header" href="#輸出錯誤">輸出錯誤</a></h2>
<p>輸出錯誤的部分應透過 stderr 完成，
以便使用者和其它工具更方便的地將輸出通過管道傳輸到文件或更多的工具中。</p>
<aside>
<p><strong>說明:</strong>
在大部分作業系統中，
一個程式可以將輸出寫入至兩個串流中，<code>stdout</code> 和 <code>stderr</code>。
<code>stdout</code> 用於程式的實際輸出，而 <code>stderr</code> 可將錯誤或其它資訊與 <code>stdout</code> 分開。
這樣，
正確輸出的部分可以儲存到檔案或管道傳輸到其它程式中，同時將錯誤顯示給使用者。</p>
</aside>
<p>在 Rust 中，
使用 <code>println!</code> 和 <code>eprintln!</code>，
前者對應 <code>stdout</code> 和後者對應 <code>stderr</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("This is information");
eprintln!("This is an error! :(");
<span class="boring">}</span></code></pre></pre>
<aside>
<p><strong>小心</strong>:</p>
<p>輸出 <a href="https://en.wikipedia.org/wiki/ANSI_escape_code">跳脫碼</a> 可能很危險，
會導致使用者的終端變成奇怪的狀態。
手動輸出至終端時請務必小心使用！</p>
<p>當你處理原始<a href="https://en.wikipedia.org/wiki/ANSI_escape_code">跳脫碼</a>時，
最好使用像 <code>ansi_term</code> 這樣的 <code>crate</code>，
以便你（和你程式的使用者）更加放心。</p>
</aside>
<h2 id="關於輸出至終端的效能說明"><a class="header" href="#關於輸出至終端的效能說明">關於輸出至終端的效能說明</a></h2>
<p>輸出到終端時出奇的慢！
如果你在迴圈中呼叫 <code>println!</code> 之類的東西，
它很容易成為其它運行速度快的程式的瓶頸。
你可以做兩件事來為它提升速度。</p>
<p>首先，
你需要盡量減少實際「刷新」到終端的寫入次數。
<em>每次</em> 呼叫 <code>println!</code> 時，
它都會告訴系統刷新到終端，
因為列印每個新行是很常見的。
如果你不需要如此，
你可以使用 <a href="https://doc.rust-lang.org/1.39.0/std/io/struct.BufWriter.html"><code>BufWriter</code></a> 來包裝一下 <code>stdout</code> 的句柄，
它的預設快取為 8 kB。
( 當你想立即輸出至終端時，請在 <code>BufWriter</code> 上呼叫 <code>.flush()</code> 即可。)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = io::BufWriter::new(stdout); // optional: wrap that handle in a buffer
writeln!(handle, "foo: {}", 42); // add `?` if you care about errors here
<span class="boring">}</span></code></pre></pre>
<p>其次，
為 <code>stdout</code>（或 <code>stderr</code> ）申請一把鎖並使用 <code>writeln!</code> 來直接輸出至終端會很有用。
它會阻止系統不停地鎖定並解鎖 <code>stdout</code>。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};

let stdout = io::stdout(); // get the global stdout entity
let mut handle = stdout.lock(); // acquire a lock on it
writeln!(handle, "foo: {}", 42); // add `?` if you care about errors here
<span class="boring">}</span></code></pre></pre>
<p>你也可以結合且使用這兩種方式。</p>
<h2 id="顯示進度條"><a class="header" href="#顯示進度條">顯示進度條</a></h2>
<p>有些 CLI 程式的運作時間很長，
會花費幾分鐘甚至數小時。
如果你在編寫這種程式，
你可能想要向使用者展示，其程式正在正常運作中。
因此，你需要輸出有用的狀態更新訊息，
最好是使用易於使用的方式來進行輸出。</p>
<p>Using the <a href="https://crates.io/crates/indicatif">indicatif</a> crate,
you can add progress bars
and little spinners to your program.
Here’s a quick example:</p>
<pre><code class="language-rust ignore">fn main() {
    let pb = indicatif::ProgressBar::new(100);
    for i in 0..100 {
        do_hard_work();
        pb.println(format!("[+] finished #{}", i));
        pb.inc(1);
    }
    pb.finish_with_message("done");
}</code></pre>
<p>See the <a href="https://docs.rs/indicatif">documentation</a>
and <a href="https://github.com/console-rs/indicatif/tree/main/examples">examples</a>
for more information.</p>
<h2 id="記錄檔"><a class="header" href="#記錄檔">記錄檔</a></h2>
<p>為了更方便了解我們的程式做了什麼，
我們需要為它加入一些記錄檔的相關語句，這很簡單。
但在長時間後，例如半年後再執行這個程式時，
記錄檔就變得非常有用了。
在某些方面來說，
記錄的使用方法與 <code>println</code> 一樣類似，
只是它可以指定訊息的重要性（層級）。
通常可以使用的層級包括 <em>error</em> , <em>warn</em>, <em>info</em> , <em>debug</em> , 和 <em>trace</em>
（ <em>error</em> 優先順序最高， <em>trace</em> 最低）。</p>
<p>To add simple logging to your application,
you’ll need two things:
The <a href="https://crates.io/crates/log">log</a> crate (this contains macros named after the log level)
and an <em>adapter</em> that actually writes the log output somewhere useful.
Having the ability to use log adapters is very flexible:
You can, for example, use them to write logs not only to the terminal
but also to <a href="https://en.wikipedia.org/wiki/Syslog">syslog</a>, or to a central log server.</p>
<p>Since we are right now only concerned with writing a CLI application,
an easy adapter to use is <a href="https://crates.io/crates/env_logger">env_logger</a>.
It’s called “env” logger because you can
use an environment variable to specify which parts of your application
you want to log
(and at which level you want to log them).
It will prefix your log messages with a timestamp
and the module where the log messages come from.
Since libraries can also use <code>log</code>,
you easily configure their log output, too.</p>
<p>Here’s a quick example:</p>
<pre><code class="language-rust ignore">use log::{info, warn};

fn main() {
    env_logger::init();
    info!("starting up");
    warn!("oops, nothing implemented!");
}</code></pre>
<p>Assuming you have this file as <code>src/bin/output-log.rs</code>,
on Linux and macOS, you can run it like this:</p>
<pre><code class="language-console">$ env RUST_LOG=info cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>In Windows PowerShell, you can run it like this:</p>
<pre><code class="language-console">$ $env:RUST_LOG="info"
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p>In Windows CMD, you can run it like this:</p>
<pre><code class="language-console">$ set RUST_LOG=info
$ cargo run --bin output-log
    Finished dev [unoptimized + debuginfo] target(s) in 0.17s
     Running `target/debug/output-log.exe`
[2018-11-30T20:25:52Z INFO  output_log] starting up
[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!
</code></pre>
<p><code>RUST_LOG</code> is the name of the environment variable
you can use to set your log settings.
<code>env_logger</code> also contains a builder
so you can programmatically adjust these settings,
and, for example, also show <em>info</em> level messages by default.</p>
<p>There are a lot of alternative logging adapters out there,
and also alternatives or extensions to <code>log</code>.
If you know your application will have a lot to log,
make sure to review them,
and make your users’ life easier.</p>
<aside>
<p><strong>貼士:</strong>
Experience has shown that even mildly useful CLI programs can end up being used for years to come.
(Especially if they were meant as a temporary solution.)
If your application doesn’t work
and someone (e.g., you, in the future) needs to figure out why,
being able to pass <code>--verbose</code> to get additional log output
can make the difference between minutes and hours of debugging.
The <a href="https://crates.io/crates/clap-verbosity-flag">clap-verbosity-flag</a> crate contains a quick way
to add a <code>--verbose</code> to a project using <code>clap</code>.</p>
</aside>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorial/errors.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorial/testing.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorial/errors.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorial/testing.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
